configfile: "./snakefile_config"
import pandas as pd

#filling the QSEQIDS list for the input wildcard "qseqid" in the all rule
QSEQIDS = []
with open(config['query_sequence'],'r') as qseqfile:
	for line in qseqfile.readlines():
		if ">" in line:
			#TODO adjust qseq_ids in query_sequence file in order to assign a new unique name ? - until now just refseq OR local database sequence headers are allowed
			qseq_id = line.split(" ")[0].split(">")[1].split(".")[0]
			QSEQIDS.append(qseq_id)

rule all:
	input:
		expand("{qseqid}/target_sequences.faa",qseqid=QSEQIDS),
		"reciprocal_results.html",
		 "plot_amount_hits_of_target_taxon.png",
		 "plot_evalue_distribution.png",
		 "reciprocal_results.csv",
		 "reciprocal_results_info.txt",
		 "query_sequence_information.html",
		"query_sequence_information.csv",

rule forward_blast:
	input: fw_queries=config['query_sequence']
	output: "blastp_fw_out.table"
	params: word_size=config['fw_word_size'], e_value=config['fw_e_value'], num_alignments=config['fw_num_alignments'], num_threads=config['fw_num_threads'], database=config['blastdb']
	shell:
		"blastp -db {params.database} -outfmt \"6 qseqid sseqid pident evalue bitscore qgi sgi sacc staxids sscinames scomnames stitle\" -out {output} -word_size {params.word_size} -evalue {params.e_value} -num_alignments {params.num_alignments} -num_threads {params.num_threads} -query {input.fw_queries}"

#collects the subject id's of the forward BLAST and writes those id's into a file that is used by the next rule
rule fw_result_processing:
	input: fw_res="blastp_fw_out.table"
	output: gi_list="bw_queries_gi_list_for_blastdbcmd.txt"
	run:
		fw_results = pd.read_table(input[0], header=None)
		out = open(output[0],"w+")
		for gi in fw_results[7][:].unique():
			out.write(gi+"\n")
		out.close()

#prepares the backward query fasta file
rule bw_query_preparation:
	input: "bw_queries_gi_list_for_blastdbcmd.txt"
	output: "bw_queries.faa"
	params: database=config["blastdb"]
	shell:
		"blastdbcmd -db {params.database} -entry_batch {input} -out {output}"

rule backward_blast:
	input: bw_queries="bw_queries.faa"
	output: "blastp_bw_out.table"
	params: word_size=config['bw_word_size'],e_value=config['bw_e_value'],num_alignments=config['bw_num_alignments'],max_hsps=config['bw_max_hsps'],num_threads=config['bw_num_threads'],taxid=config['bw_taxid'],database=config['backwarddb'],intermediate_filename="inter_blast.table"
	run:
		sequence_dict = {}
		with open(input[0],'r') as infile:
			for line in infile.readlines():
				if line.startswith(">"):
					header = line.split(" ")[0].split(">")[-1]
					sequence_dict[header] = ''
				if header:
					sequence_dict[header] += line

		filenames = ["bw_queries_" + str(i) + ".faa" for i in range(round(len(sequence_dict.keys()) / 500.0))]
		keys = list(sequence_dict.keys())

		step = 500
		start = 0
		filecounter = 0
		end = 500
		while start < len(keys) and filecounter < len(filenames):
			with open(filenames[filecounter],'w') as outfile:
				for key in keys[start:end]:
					for line in sequence_dict[key]:
						outfile.write(line)
				start = end
				end += step
				filecounter += 1
		inter_blast_out = open("blast.table",'w')
		for file in filenames:
			shell("blastp -db {params.database} -outfmt \"6 qseqid sseqid pident evalue bitscore qgi sgi sacc staxids sscinames scomnames stitle\" -out {params.intermediate_filename} -taxids {params.taxid} -word_size {params.word_size} -evalue {params.e_value} -num_alignments {params.num_alignments} -max_hsps {params.max_hsps} -num_threads {params.num_threads} -query {file}")
			with open(params.intermediate_filename,'r') as interfilename:
				for line in interfilename.readlines():
					inter_blast_out.write(line)
		inter_blast_out.close()
		for file in filenames:
			shell("rm {file}")
		shell("rm inter_blast.table")
		shell("mv blast.table {output}")

rule reciprocal_best_hits:
	input: bw_res="blastp_bw_out.table", fw_res="blastp_fw_out.table"
	output: rec_best_hits="reciprocal_best_hits_protein_ids.txt"
	script:
		"../../../static/snakefiles/reciprocal_blast/extract_reciprocal_best_hits.py"

rule blast_tables_to_html:
	input: rec_res="reciprocal_results_with_taxonomy.csv"
	output: rec_html="reciprocal_results.html"
	script:
		"../../../static/snakefiles/reciprocal_blast/blast_tables_to_html.py"

rule blast_tables_to_csv:
	input: fw_res="blastp_fw_out.table", rec_res="reciprocal_best_hits_protein_ids.txt", query_file=config['query_sequence']
	output: result_csv="reciprocal_results.csv", taxonomy_result_csv='reciprocal_results_with_taxonomy.csv'
	script:
		"../../../static/snakefiles/reciprocal_blast/blast_tables_to_orthologous_table.py"

rule reciprocal_results_table_to_target_sequences:
	input: result_csv="reciprocal_results.csv", query_file=config['query_sequence']
	output: hit_information="reciprocal_results_info.txt",queries=expand("{qseqid}/target_sequence_ids.txt",qseqid=QSEQIDS)
	script:
		"../../../static/snakefiles/reciprocal_blast/build_folders_with_hit_info_for_each_qseqid.py"

rule extract_subject_sequences_from_database:
	input: "{qseqid}/target_sequence_ids.txt"
	output: "{qseqid}/target_sequences.faa"
	params: database=config["blastdb"]
	shell:
		 "blastdbcmd -db {params.database} -entry_batch {input} -out {output}"

rule blast_tables_to_plots:
	input: fw_res="blastp_fw_out.table", rec_res="reciprocal_best_hits_protein_ids.txt",query_file=config['query_sequence']
	params:
		plot_hits_organisms_png="../../../static/images/result_images/" + str(config['project_id']) + '/plot_amount_hits_of_target_taxon.png',
		plot_evalues="../../../static/images/result_images/" + str(config['project_id']) + '/plot_evalue_distribution.png'
	output: taxids_hits_plot="plot_amount_hits_of_target_taxon.png",evalue_plot="plot_evalue_distribution.png"
	script:
		  "../../../static/snakefiles/reciprocal_blast/plot_reciprocal_results.py"

rule query_sequences_to_html_table:
	input: target_file=config['query_sequence']
	params: email=config['user_email']
	output: output_html="query_sequence_information.html", output_csv="query_sequence_information.csv"
	script:
		"../../../static/snakefiles/reciprocal_blast/query_sequences_to_html_table.py"